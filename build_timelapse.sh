#!/bin/bash
version="0.1"
#
# This is an optional arguments-only example of Argbash potential
#
# ARG_OPTIONAL_BOOLEAN([rename],[n],[Rename Images to stabilise the order],[on])
# ARG_OPTIONAL_BOOLEAN([resize],[s],[Resize to 1080p],[on])
# ARG_OPTIONAL_BOOLEAN([deflicker],[l],[Deflicker to even out lighting changes],[on])
# ARG_OPTIONAL_BOOLEAN([gif],[g],[Make GIF only on less than 25 frames],[off])
# ARG_OPTIONAL_BOOLEAN([avi],[a],[Make AVI video file],[on])
# ARG_OPTIONAL_BOOLEAN([mkv],[k],[Make MKV video file],[off])
# ARG_OPTIONAL_BOOLEAN([mov],[m],[Make MOV video file (unsupported atm)],[off])
# ARG_OPTIONAL_SINGLE([fps],[f],[Frames Per Second],[25])
# ARG_OPTIONAL_SINGLE([crop],[c],[Percentage of photo to use],[100])
# ARG_OPTIONAL_SINGLE([offsetx],[x],[X Offset to crop from],[0])8
# ARG_OPTIONAL_SINGLE([offsety],[y],[Y Offset to crop from],[0])
# ARG_OPTIONAL_INCREMENTAL([verbose],[V],[how much verbose to be])
# ARG_VERSION([echo v$version])
# ARG_HELP([Make time lapse images froma folder of images])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='nslgakmfcxyVvh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_rename="on"
_arg_resize="on"
_arg_deflicker="on"
_arg_gif="off"
_arg_avi="on"
_arg_mkv="off"
_arg_mov="off"
_arg_fps="25"
_arg_crop="100"
_arg_offsetx="0"
_arg_offsety="0"
_arg_verbose=0

print_help ()
{
	printf '%s\n' "Make time lapse images froma folder of images"
	printf 'Usage: %s [-n|--(no-)rename] [-s|--(no-)resize] [-l|--(no-)deflicker] [-g|--(no-)gif] [-a|--(no-)avi] [-k|--(no-)mkv] [-m|--(no-)mov] [-f|--fps <arg>] [-c|--crop <arg>] [-x|--offsetx <arg>] [-y|--offsety <arg>] [-V|--verbose] [-v|--version] [-h|--help]\n' "$0"
	printf '\t%s\n' "-n,--rename,--no-rename: Rename Images to stabilise the order (on by default)"
	printf '\t%s\n' "-s,--resize,--no-resize: Resize to 1080p (on by default)"
	printf '\t%s\n' "-l,--deflicker,--no-deflicker: Deflicker to even out lighting changes (on by default)"
	printf '\t%s\n' "-g,--gif,--no-gif: Make GIF only on less than 25 frames (off by default)"
	printf '\t%s\n' "-a,--avi,--no-avi: Make AVI video file (on by default)"
	printf '\t%s\n' "-k,--mkv,--no-mkv: Make MKV video file (off by default)"
	printf '\t%s\n' "-m,--mov,--no-mov: Make MOV video file (unsupported atm) (off by default)"
	printf '\t%s\n' "-f,--fps: Frames Per Second (default: '25')"
	printf '\t%s\n' "-c,--crop: Percentage of photo to use (default: '100')"
	printf '\t%s\n' "-x,--offsetx: X Offset to crop from (default: '0')"
	printf '\t%s\n' "-y,--offsety: Y Offset to crop from (default: '0')"
	printf '\t%s\n' "-V,--verbose: how much verbose to be"
	printf '\t%s\n' "-v,--version: Prints version"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-n|--no-rename|--rename)
				_arg_rename="on"
				test "${1:0:5}" = "--no-" && _arg_rename="off"
				;;
			-n*)
				_arg_rename="on"
				_next="${_key##-n}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-n" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-s|--no-resize|--resize)
				_arg_resize="on"
				test "${1:0:5}" = "--no-" && _arg_resize="off"
				;;
			-s*)
				_arg_resize="on"
				_next="${_key##-s}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-s" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-l|--no-deflicker|--deflicker)
				_arg_deflicker="on"
				test "${1:0:5}" = "--no-" && _arg_deflicker="off"
				;;
			-l*)
				_arg_deflicker="on"
				_next="${_key##-l}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-l" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-g|--no-gif|--gif)
				_arg_gif="on"
				test "${1:0:5}" = "--no-" && _arg_gif="off"
				;;
			-g*)
				_arg_gif="on"
				_next="${_key##-g}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-g" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-a|--no-avi|--avi)
				_arg_avi="on"
				test "${1:0:5}" = "--no-" && _arg_avi="off"
				;;
			-a*)
				_arg_avi="on"
				_next="${_key##-a}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-a" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-k|--no-mkv|--mkv)
				_arg_mkv="on"
				test "${1:0:5}" = "--no-" && _arg_mkv="off"
				;;
			-k*)
				_arg_mkv="on"
				_next="${_key##-k}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-k" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-m|--no-mov|--mov)
				_arg_mov="on"
				test "${1:0:5}" = "--no-" && _arg_mov="off"
				;;
			-m*)
				_arg_mov="on"
				_next="${_key##-m}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-m" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-f|--fps)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_fps="$2"
				shift
				;;
			--fps=*)
				_arg_fps="${_key##--fps=}"
				;;
			-f*)
				_arg_fps="${_key##-f}"
				;;
			-c|--crop)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_crop="$2"
				shift
				;;
			--crop=*)
				_arg_crop="${_key##--crop=}"
				;;
			-c*)
				_arg_crop="${_key##-c}"
				;;
			-x|--offsetx)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_offsetx="$2"
				shift
				;;
			--offsetx=*)
				_arg_offsetx="${_key##--offsetx=}"
				;;
			-x*)
				_arg_offsetx="${_key##-x}"
				;;
			-y|--offsety)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_offsety="$2"
				shift
				;;
			--offsety=*)
				_arg_offsety="${_key##--offsety=}"
				;;
			-y*)
				_arg_offsety="${_key##-y}"
				;;
			-V|--verbose)
				_arg_verbose=$((_arg_verbose + 1))
				;;
			-V*)
				_arg_verbose=$((_arg_verbose + 1))
				_next="${_key##-V}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					begins_with_short_option "$_next" && shift && set -- "-V" "-${_next}" "$@" || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-v|--version)
				echo v$version
				exit 0
				;;
			-v*)
				echo v$version
				exit 0
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_PRINT_HELP=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
		esac
		shift
	done
}

parse_commandline "$@"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash


# Options
RENAME="$_arg_rename"
RESIZE="$_arg_resize"
DEFLICKER="$_arg_deflicker"
GIF="$_arg_gif"
AVI="$_arg_avi"
MKV="$_arg_mkv"
MOV="$_arg_mov"
FPS=$_arg_fps
CROP=false
if [ "$_arg_crop" != "100" ];
then
	CROP=true
fi
SCALE=$_arg_crop
OFFSETX=$_arg_offsetx
OFFSETY=$_arg_offsety

echo "RENAME = $RENAME"
echo "RESIZE = $RESIZE"
echo "DEFLICKER = $DEFLICKER"
echo "GIF = $GIF"
echo "AVI = $AVI"
echo "MKV = $MKV"
echo "MOV = $MOV"
echo "FPS = $FPS"

echo "crop = $CROP @ ${SCALE}%x+${OFFSETX}+${OFFSETY}"


SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done

SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

PHOTO_DIR=$(pwd)
CURR_DIR=$PHOTO_DIR

PHOTO_NAME="${PHOTO_DIR##*/}"
 if $CROP;
  then
PHOTO_NAME="${PHOTO_DIR##*/}_${SCALE}_${OFFSETX}_${OFFSETY}"
  fi

echo ${PHOTO_NAME}

#exit

if [ $RENAME = on ];
then
  echo "Renaming"
  CURR_DIR="$CURR_DIR/renamed"
  mkdir "$CURR_DIR"
  counter=1
  ls -1tr *.JPG | while read filename; do cp $filename "$CURR_DIR/$(printf %05d $counter)_$filename"; ((counter++)); done
  cd "$CURR_DIR"
fi

if [ $RESIZE = on ];
then
  echo "Resizing"

  if $CROP;
  then
    CURR_DIR="$CURR_DIR/resized_${SCALE}_${OFFSETX}_${OFFSETY}"
  else
    CURR_DIR="$CURR_DIR/resized"
  fi
  mkdir "$CURR_DIR"
  mogrify -path "$CURR_DIR" -crop ${SCALE}%x+${OFFSETX}+${OFFSETY} -resize 1920x1080! *.JPG
  cd "$CURR_DIR"
fi

if [ $DEFLICKER = on ];
then
  echo "Deflickering"
  ${SCRIPT_DIR}/timelapse-deflicker.pl
  CURR_DIR="$CURR_DIR/Deflickered"
  cd "$CURR_DIR"
fi

count=$(find . -maxdepth 1 -type f -name '*' | wc -l)

if [ $count -lt 30 ] && [ $GIF = on] ; then
    echo "Making GIF"
    convert -delay 100  -loop 0 *.JPG "${PHOTO_NAME}.gif"
fi

if [ $AVI = on ];
then
  echo "Making AVI"
  ffmpeg -framerate $FPS -pattern_type glob -i '*.JPG' -c:v copy "${PHOTO_NAME}.avi"
fi

if [ $MKV = on ];
then
  echo "Making MKV"
  ffmpeg -i "${PHOTO_NAME}.avi" -c:v libx264 -preset slow -crf 15 "${PHOTO_NAME}.mkv"
fi

cp "${PHOTO_NAME}".*  "$PHOTO_DIR/../"
cd "$PHOTO_DIR/"


# ] <-- needed because of Argbash
